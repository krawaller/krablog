<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: release | Krawaller webdev blog]]></title>
  <link href="http://krawaller.github.com/krablog/blog/categories/release/atom.xml" rel="self"/>
  <link href="http://krawaller.github.com/krablog/"/>
  <updated>2013-02-24T16:55:26+01:00</updated>
  <id>http://krawaller.github.com/krablog/</id>
  <author>
    <name><![CDATA[Krawaller]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Titanium app for explaining layout mechanisms]]></title>
    <link href="http://krawaller.github.com/krablog/titanium-app-for-explaining-layout-mechanisms/"/>
    <updated>2011-08-04T00:00:00+02:00</updated>
    <id>http://krawaller.github.com/krablog/titanium-app-for-explaining-layout-mechanisms</id>
    <content type="html"><![CDATA[<div class="summarytext">Wrapping our brains around Titanium View layouts!</div>


<p>During a recent app project, I felt constantly hampered by not having a strong enough ninjutsu understanding of laying out things in a Titanium app. How does horizontal and vertical layout actually work? What's the difference between a View, a ScrollView and a ScrollableView? When having too much content to show on screen, do I want the parent or child to scroll? What happens when I have a scrolling child in a scrolling parent?</p>


<p>I constantly had to pause my work to peruse the Titanium docs/kitchensink/sourcecode, or (more often) do some experimenting on the side, regarding stuff that I suspected I really should have nailed down. It felt like doing maths without having memorized the multiplication tables!&nbsp;</p>


<h3>The TiView app</h3>


<p>Eventually the added-up frustration got too great, so I set aside some time for grokking and getting comfortable with the API. This resulted in a small Titanium application we call <strong>TiView</strong>. It has a number of demos, showing on screen what various layout properties will actually result in. Most of it probably already obvious to most of you out there, but I felt it helped me to "say it out loud" in this way.</p>


<p>As stated the app is very simple. It has a number of demos, ordered into categories. The screenshot below shows the current content, I hope to add some more to it before I move on too far:&nbsp;</p>


<p>[[posterous-content:frowHAoziJDnxttahjCg]]Each category then consists of a ScrollableView, where each view is a demo of some layout code. The properties used are displayed inside the laid-out child:</p>


<p>[[posterous-content:ufiCtpiiqrnHFAacpcgH]]</p>


<p>The source code is available in the Git repo <a href="http://github.com/krawaller/tiview" title="TiView git repo" target="_blank">here</a>. Have a snoop and see if might be of any help. Or even better, add more demos of your own! It's just 250 lines in a single file, and all the demos are just object literals sent into a constructor function, so getting your own ideas in there shouldn't require that strong a shoe-horn:</p>


<script src="https://gist.github.com/1125138.js?file=gistfile1.js"></script>


<h3>Android VS iPhone</h3>


<p>When we ran the app on an Android, it turned out that there where even more difference in behaviour between the platforms that we had originally thought! Therefore we gave the demos platform-specific descriptions.</p>


<p>This process was hugely informative for us - not only did we gain a better understanding of the layout API:s, but also of the (many) differences between the platforms! Having a good map of these differences will make it much easier to write code that won't behave differently on the other platform.</p>


<p>So we encourage you to try out TiView, and hope it will be of use!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium application structure â€“ learning from Tweetanium]]></title>
    <link href="http://krawaller.github.com/krablog/titanium-application-structure-learning-from/"/>
    <updated>2011-02-16T00:00:00+01:00</updated>
    <id>http://krawaller.github.com/krablog/titanium-application-structure-learning-from</id>
    <content type="html"><![CDATA[<div class="summarytext">Struct - learning from Tweetanium regarding application structure best practices!</div>


<p>Up until recently, like so many other lost souls, we've followed the same Titanium application structure as Appcelerator's KitchenSink application. In this paradigm, when you want to open a new window, you'd typically do something like this:</p>


<script src="https://gist.github.com/829615.js?file=openingwindow.js"></script>


<p>Inside somefile.js the window would be populated with controls, using the Ti.UI.currentWindow reference. We can access the data from the previous window through win.importantdata.</p>


<p>This approach, even when improved upon, has several disadvantages:</p>


<ul>
<li> If you have a file with application helper functions, you need to import that in every other file that needs the functionality. In my Tristania app for example, pretty much every file starts with Ti.include(&ldquo;../assets/utils.js&rdquo;).</li>
<li> Every time a window is meant to be created, the relevant file must be read and code parsed.</li>
<li>The structure of the app becomes rather opaque.</li>
<li>It is very difficult to unittest this approach.</li>
</ul>


<p>It all works, sure, but I've never been comfortable with my application structures, feeling there must be a better way. Even though there are (many) ways to improve on the above example, I wanted a different structure paradigm alltogether. Alas, I was too lazy to get around to experiment with it, so &ldquo;it remained but a beautiful thought&rdquo;, as we say in Sweden.</p>


<p>Fortunately, <a href="http://twitter.com/kevinwhinnery">Kevin Whinnery</a>, <a href="http://twitter.com/chadauld">Chad Auld</a> and the rest of the Appcelerator team have no such character flaws! Recently they <a href="http://developer.appcelerator.com/blog/2011/01/tweetanium-source-code-release.html">opensourced Tweetanium</a>, a fully functioning Twitter client coded with best practices regarding both JavaScript in general and Titanium in particular.</p>


<p>Which was like christmas to me! The only non-Krawaller Titanium source code I've gleaned (with a few none-noteworthy exceptions) is the aforementioned KitchenSink, which &ndash; let's be honest &ndash; is not a great piece of work at all. It demonstrates the API very well (which is great since the docs are crap), but as an application example, it leaves me wanting.</p>


<p>So, enter Tweetanium. As soon as you open up the sourcecode, it is evident that they're doing things very differently! I have created a stripped-down, barebones version of it called Struct, aiming to expose the new structure paradigm. You'll find the git repo <a href="https://github.com/krawaller/struct">here</a>. This is what it looks like &ndash; isn't knowledge beautiful? :)</p>


<p>[[posterous-content:GjClsyjFxfyzfhrEvEFH]]</p>


<p>The main point in the Tweetanium approach is that my various files (like somefile.js in the above example) are not messing with Ti.UI.currentWindow &ndash; instead, it augments a global namespace with a constructor variable. In Struct, I end up with the following global object:</p>


<script src="https://gist.github.com/829615.js?file=globalobject.js"></script>


<p>The program flow is that the otherwise pretty empty app.js imports struct.js, which can be considered your main app definition file. This file creates the global namespace and maybe some utility functions, and then includes the other files to populate the rest of the namespace.</p>


<p>This means that as soon as the struct.js file is included, the entire app structure is created in memory. No more parsing of files will be done during the session.</p>


<p>App.js will then call the createApplicationWindow function, call the open method on the returned window, and maybe do some other app initialization stuff. Now the app is up and running! In Struct, app.js looks like this:</p>


<script src="https://gist.github.com/829615.js?file=app.js"></script>


<p>So what are the great advantages to this approach? I've already found quite a few, but it boils down to a single keyword: closure. Every single function is executed in the same closure (ok, maybe subclosures, but you get the gist). Read that sentence again until the implications set in.</p>


<p>This is good news from a performance perspective (and most likely stability) &ndash; no more importing the same file a gazillion times! But from an infrastructure point of view its even yummier:</p>


<ul>
<li> As we always have access to the same scope, we can keep app-wide data in a single object, instead of JSON:ing back and forth with Ti.App.Properties. </li>
<li> All kinds of other convenience     structures are suddenly very easy to build. In Struct there is a global messaging system, using one single view, instantiated only once. Tweetanium does a similar thing with a loader view, and has a  very neat Model baseclass thing going. </li>
<li> You can instantiate all app windows and views immediately, as they all live in the same closure. Windows opened at a later point will also live in the same closure, since that's where the constructor function is defined. </li>
<li> Creating your own navigation system ("immersive UI", to use Apple's lingo) is a breeze. In Struct I've stolen the home-brewed tabs from Tweetanium. </li>
</ul>


<p>Now, having autopsied Tweetanium, created Struct and looking at the layout before me, it seems very obvious and self-evident. Perhaps it already was to the rest of you, but for me it was a new-found revelation, and I can't wait to test it out in our next project! So, for those of you who like me hadn't caught on to this train before, check out <a href="https://github.com/krawaller/struct">Struct</a> &amp; <a href="http://developer.appcelerator.com/blog/2011/01/tweetanium-mobile.html">Tweetanium</a> and try it out!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Releasing Auktionera, a Tradera iPhone app]]></title>
    <link href="http://krawaller.github.com/krablog/releasing-auktionera-a-tradera-iphone-app/"/>
    <updated>2011-02-03T00:00:00+01:00</updated>
    <id>http://krawaller.github.com/krablog/releasing-auktionera-a-tradera-iphone-app</id>
    <content type="html"><![CDATA[<div class="summarytext">Releasing Auktionera, our iPhone app for the Swedish auction site Tradera!</div>


<p style="padding-left: 30px;"><strong>Update</strong>: As Tradera finally saw sense and ported the eBay app, we're pulling the Auktionera app from the App Store! One has to choose one's battles...&nbsp;</p>


<p>As Jacob wrote the Livetanium post 2 months ago, I remember us vowing to keep up the pace in the content flow to this blog. That was, as stated, two months ago, and this place has been tumbleweeding ever since. Epic fail, as the kids (<a href="http://thebestpageintheuniverse.net/c.cgi?u=epic" target="_blank">erroneously</a>) say these days!&nbsp;</p>


<p>One of our excuses is a pretty intense development of an iPhone app for the swedish auction site Tradera, which is now released to the App Store! <a href="http://itunes.apple.com/se/app/id416520953">Here</a>'s a shop link, and we also created a little <a href="http://auktionera-app.se" title="Auktionera app support site" target="_blank">support site</a> with some more information (in Swedish).</p>


<h3>Functionality</h3>


<p>The app is a pretty standard auction site app, much like the eBay one. You can peruse auctions, bid, create your own auctions, save favourite searhes / users / auctions, check seller history, etc.</p>


<p>[[posterous-content:ItBjeFqdGnhGEbvbsdwz]]</p>


<p>Made with love and care, but pretty boring, in other words. This was also our approach as we entered the project. We weren't&nbsp;really intrigued by the technical challenges, but&nbsp;thought this had a good chance of selling well. This mainly because there <a href="http://itunes.apple.com/us/app/id363997028?mt=8" title="The competition!" target="_blank">already was an app in the store</a>, selling better than our Systemet in spite of being rather crap.&nbsp;</p>


<p>This competing app is getting flak because of two different things:</p>


<ul>
<li>It is, as stated, rather crappy, being very prone to crash. Also some functions have ceased to work after the latest iOS upgrades.&nbsp;</li>
<li>It relies completely on <a href="http://api.tradera.com/" title="Tradera API" target="_blank">Tradera's official API</a>, which for whatever reason is missing some vital functionality, such as checking out a seller's previous history. This is, naturally, something that an auctioneer want to be able to do, before taking the plunge and risking those hard-earned dimes!</li>
</ul>


<p>Our tactic was therefore a mirror image of this list:</p>


<ul>
<li>Make sure the app doesn't crash and burn!</li>
<li>Complement the official API functionality with some YQL scraping on the side.</li>
</ul>


<p>Sounded easy enough, but it turned out that none of the above was as straight-forward as we thought..</p>


<h3>Titanium stability</h3>


<p>After a lengthy development cycle in Titanium and the emulator, we did a first reality test on an actual device. We weren't really worried, as the app flowed very neatly in the emulator. But, as we fired it up on the phone, we discovered to our dismay that we had managed to copy the very fickleness we wanted to avoid! The app would crash in random places, not leaving any definite clues as to why.&nbsp;</p>


<p>Not until we ran the app in an emulator next to the activity monitor did we find out why. It turned out that Titanium did some things rather inefficiently, which would eventually cause the phone to run out of memory or processor juice. The same thing happened in the emulator, but there it wouldn't hit the ceiling as soon, as the computer has much more resources.&nbsp;</p>


<p>So, what were these inefficient things that Titanium did? Well:</p>


<ul>
<li>First off - <strong>don't handle XML</strong> in your app, unless you can avoid it. XML is of course painful in and of itself, but Titanium's garbage collection somehow cannot clean up after xml parsing. Try it: open a new window, parse some XML, then close that window (using the back button, for example), and watch the processor usage spike, never to drop again.&nbsp;</li>
<li>Be careful when doing <strong>advanced table creation</strong>. Use the best practices detailed in the <a href="http://assets.appcelerator.com.s3.amazonaws.com/docs/API_UITableViewClass.pdf" target="_blank">documentation</a>, and test your table generation with the Activity indicator running. For some combinations of table gymnastics, the memory usage will be intolerably high, eventually making the app crash.</li>
<li>If you have a large data structure, <strong>prefer a sqlite database</strong> to just keeping a big object in memory. This might be obvious to the rest of the world, but took us a bit off guard - intuitively, we thought it would be more efficient to keep a single object and query that, skipping the overhead cost of a database. However, some testing proved us very wrong indeed - the sqlite database is quicker and uses far less memory.</li>
</ul>


<p>So we learned some specifics, but the main lesson for us was this: do <strong>frequent reality checks</strong> on an actual device. Titanium is still a young framework with many rough edges, and some of those edges will not cut you in the emulator since that does not correctly emulate the hardware limitations.&nbsp;</p>


<h3>YQL + Tradera = somewhat true</h3>


<p>We also had a rough time with the intermingling of official functionality and our home-brewed YQL-fueled queries. There were several authentication and authorization models involved; the Tradera API requires an App-Id, the user must be authenticated through the API, and also through the official site for our scraping to work.&nbsp;</p>


<p>When starting off, we had all this in a spaghetti-bowl of code in the app. Lots of moving parts, lots of things that could break at any time. Not until we isolated all of this to a PHP-bridge did the different parts fall into place. This is of course what we should have done from the beginning - separations of concern is something we frequently preach to others. But somehow we fooled ourselves into thinking we'd already done this, as we has lots of logic in the YQL OpenTables. The lesson: you can always abstract your code one step further. :)</p>


<h3>API design IS an artform</h3>


<p>The biggest challenge, however, was actually using the Tradera API. I now realize that I've taken usability and intuitivity for granted in the API:s that I use, not thinking much of it. It's like appreciating your mom doing all the household chores - you don't, until you move out. I had no idea that designing a good API takes work, until I used a bad one.</p>


<p>Now, you shouldn't bite the hand that feeds you, but the Tradera API is pretty horrid. There seems to be no general rule for naming functions (camel casing, lower case, it's the wild west in there). The same property names mean different things in different functions. Documented properties are sometimes populated, sometimes not, depending on the weather and alignent of planets. Functionality between functions overlap, but never so much that you can ignore one function and just use the other.</p>


<p>And, most jarringly - there are several spelling errors in the API! When first creating our infrastructure to make calls, I tested it using the most simple function "GetOfficialTime", requiring no parameters and just returning a flat data object. It didn't work. Several hours later of reading SOAP specs and going through the code, I found the error - I needed to spell it "GetOfficalTime", note the missing "i". Fast forward a few weeks, and the same thing happened again when we tried to filter out used goods with the search parameter "ItemCondition". It was supposed to be "ItemConditon", again note the missing "i".&nbsp;</p>


<p>In Tradera's&nbsp;defense, the misspellings are also present in the documentation, and they offer free support for developers using the API, which we found very helpful. But still, it made me better at appreciate good API design. And more on my guard when using them.</p>


<h3>The result</h3>


<p>In the end we feel pretty proud of the result! This in spite of entering the project with little heart, and being in some serious stability trouble mid-journey. So, now to the boring side of things - pushing the app, spreading the word. As previously lamented, this is not what we do best.</p>


<p>Anyhow, hope the Swedish speakers among you will check the app out! Next up, Jacob will do a (less chatty) write-up on his neat method for deploying app builds to testers, right, brother? The pressure is on!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Releasing Tristania fan app]]></title>
    <link href="http://krawaller.github.com/krablog/releasing-tristania-fan-app/"/>
    <updated>2010-10-21T00:00:00+02:00</updated>
    <id>http://krawaller.github.com/krablog/releasing-tristania-fan-app</id>
    <content type="html"><![CDATA[<div class="summarytext">The Tristania iPhone app is now finally finished and available in the App Store!</div>


<p>We are proud to announce the release of our latest creation; the official app for the magnificent metal band <a href="http://www.tristania.com" title="Tristania's official homepage" target="_blank">Tristania</a>!&nbsp;</p>


<p>[[posterous-content:cCIiuwqEGmfzemizpFzI]]</p>


<p>&nbsp;</p>


<h3>Features:</h3>


<p>To get a feel for the app, please peruse the screenshots below:</p>


<p>[[posterous-content:fvArwGHAovhlBCEobCwy]]</p>


<p>With the app you can follow Tristania's various digital presences such as the official homepage, Twitter, Facebook, YouTube, gallery etc, from one convenient place. You'll also find a comprehensive discography section with lyrics and band comments, as well as other related band information. Some discussion on the included features can be found in&nbsp;<a href="http://blog.krawaller.se/headbanging-with-yql" title="previous post" target="_self">this blog post</a>.</p>


<p>If you're a Tristania fan you probably won't want to read any further, as this blog focuses on the technical side of things. Instead you might want to head on over to <a href="http://theilluminated.net/your-work/tristania-iphone-app/" title="app thread on official Tristania forum" target="_blank">this thread</a> in the official forum, where you can discuss the app, tell us of bugs, etc. But, if you're a nerd, read on!&nbsp;</p>


<h3>Used tools:</h3>


<p>Although it is unlikely that the average reader of this blog is unfamiliar with any of these JS-Ninja weaponry, here's a quick rundown of the tools used when building the Tristania app. If any of the below is missing from your toolbox, definitely rectify right away!</p>


<h4>Titanium</h4>


<p>As usual we built the application using <a href="http://www.appcelerator.com/products/titanium-mobile-application-development/" title="Titanium mobile" target="_blank">Titanium</a>, so that we can program in the language we know and love (JavaScript, as opposed to Objective C), yet still deploy it as a native application.&nbsp;</p>


<p>Although little brother has extensive experience with Titanium by now, this was my first "serious" deep-dive into the framework. Here are some of the lessons learnt during that journey:</p>


<ul>
<li>The emulator is not to be trusted, you need to <strong>make regular sanity checks on an actual device</strong>. In particular, what the emulator will not emulate is lag when a table / webview / somedetailedobject is rendered on the phone. Several times we had to refactor our code, when real-life tests revealed a certain solution to be too slow, in spite of split-second rendering in the emulator.</li>
<li>F<strong>requently delete everything in the build directory</strong>. Yes, this means that you have to perform a full rebuild to test the next iteration, which some extra takes time. But you will save yourself from hugely annoying bug hunts caused by Titanium erroneously keeping old settings in the build. Take extra care to flush build before building to the device, and definitely flush <strong>thrice</strong> before packaging for upload to app store.&nbsp;</li>
<li>Just <strong>ignore the official documentation</strong> completely. It is nowhere near complete, and full of half-truths and outright lies. Rely instead on the Kitchen Sink code. While not exactly a shining example of best practices, it has working examples of pretty much everything. When that fails, check the <a href="http://github.com/appcelerator/titanium_mobile" title="Titanium source code" target="_blank">source code</a> of Titanium itself. Also the FAQ discussion on the official homepage is a good resource.</li>
<li>Titanium is still a <strong>beta-ish platform</strong>, and sometimes the boat will be rocking for no fault of yours. But, it is getting more stable by each release, and being able to code native apps in beautiful JavaScript is worth the frustration.&nbsp;</li>
<li>The API is <strong>very low-level</strong>, as it should be. So for a large application you definitely need some kind of library to keep you sane, lest you have to type out lots of very verbose code everytime you want to create some non-trivial element. We adressed this through a little library of our own, which is slowly making its way to maturity. Especially with the <a href="http://developer.appcelerator.com/blog/2010/10/appcelerator-announces-9m-in-funding-paypal-partnership.html" title="Titanium blog" target="_blank">added investment just announced today</a>, things are only going to get better!&nbsp;</li>
</ul>


<p>Now, misunderstand me correctly - in spite of the whiny tone of the above notes, I still feel that Titanium is a remarkable framework, and that it is definitely heading in the right direction.&nbsp;</p>


<ul>
</ul>


<h4>YQL</h4>


<p>Yahoo's web service to transform any online data into beautiful JSON is nothing short of brilliant. I already sang the praise of this service in the <a href="http://blog.krawaller.se/headbanging-with-yql" title="last post" target="_blank">in-progress post</a>, so shall not reiterate that here. The main point for us was to be able to isolate fragile scraping logic outside the application, in a YQL OpenTable. Should the site we scrape change its markup, we just update the table, and all apps will instantly work again. Also, being able to pass pure JSON back to the app is wonderful, making for a beautiful separation of concerns.&nbsp;</p>


<h4>CouchOne</h4>


<p>This is another road that little brother paved for me, as he has used CouchDB in both <a href="http://blog.krawaller.se/krawaller-proudly-presents-golingo" title="Golingo release post" target="_blank">Golingo</a> and <a href="http://blog.krawaller.se/systemet" title="Systemet release post" target="_blank">Systemet</a>. For me, however, it was a completely new experience.</p>


<p>[[posterous-content:FaoDhnxvvjBnFzBBzryB]]</p>


<p>What's special about CouchDB is not just that it's all JavaScript emitting JSON (which in and of itself is really cool), but it is a (for me) whole new way to think about data. The veterans among you are probably wrinkling your noses over us youngsters never having heard of MapReduce before, but somehow I've managed to completely miss this database approach. In a MapReduce database, data isn't&nbsp;organized&nbsp;in tables. Instead it is all "documents", meaning a simple object of key-value pairs. Here, for instance, is a user document from the Tristania database:</p>


<script src="http://gist.github.com/638246.js?file=document.js"></script>


<p>Since there are no tables, you cannot simply "SELECT * FROM Users". Instead, you program a "view", using JavaScript. Every document will be sent as an argument to a "Map" function, where you choose what to emit to the result set. The result will be a JSON object with a rows array, containing all the emitted objects. Here is the map function from the users view:</p>


<script src="http://gist.github.com/638246.js?file=community.js"></script>


<p>This might sound wasteful - so we have to go through all our data, even though we're only interested in a particular well-defined subset? Somehow, however, CouchDB mitigates this, due to the way the data is stored on disc. It also remembers the result of passing a certain document to a certain map function, making the database every bit as fast and resilient as its table-based counterpart.</p>


<p>Another view in the Tristania app is the Statistics view, which also uses the Reduce function to return a single, aggregate object:</p>


<script src="http://gist.github.com/638246.js?file=statistics.js"></script>


<p>The result the same JSON structure as before, but the rows array now has only one value:</p>


<script src="http://gist.github.com/638246.js?file=result.js"></script>


<p>Still early days for the app, so as you can see above, it needs a lot more votes for the statistics data to be meaningful.</p>


<p>As with the notes on YQL etc, this isn't meant to be a CouchDB primer, but merely a way to wet your appetite if you still haven't made its acquaintance.&nbsp;</p>


<h4>GitHub</h4>


<p>So here we are definitely preaching to the choir, but I just wanted to put it to protocol that without Github, we never would have made it. We're situated in different parts of Sweden, and have been working in parallell on different parts of the application. Here's a snapshot of our Github app Network graph, showing our intertwined commits:&nbsp;</p>


<p>[[posterous-content:sEjFvonyyFjxxFHIsgHB]]</p>


<p>In our horrid pre-using-version-control days, we never could have pulled this off. Github for president!</p>


<h3>PS</h3>


<p>And, we know we've said it before, but it cannot be said too many times - go buy Rubicon, Tristania's new album! Now! :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Systemet]]></title>
    <link href="http://krawaller.github.com/krablog/systemet/"/>
    <updated>2010-07-03T00:00:00+02:00</updated>
    <id>http://krawaller.github.com/krablog/systemet</id>
    <content type="html"><![CDATA[<div class="summarytext">Announcing the release of our new app! Behind-the-scenes bean spillage to follow.</div>


<p>Yeay!</p>


<p>[[posterous-content:dcEoHdApAizvGeFbqvJI]]</p>


<p>We just wanted to let you know that our third app, <a href="http://itunes.apple.com/se/app/systemet/id379391397?mt=8">Systemet</a>, just <a href="http://itunes.apple.com/se/app/systemet/id379391397?mt=8">went live in the App Store</a>. It's an inofficial guide to the<span style="font-family: arial, sans-serif;"><span style="line-height: 15px; font-size: small;">Â Swedish Alcohol Retail Monopoly Systembolaget, and it lets you:</span></span></p>


<p><span style="font-family: arial, sans-serif;"><span style="line-height: 15px; font-size: small;"> </span></span></p>


<ul>
<li>Search for nearby stores</li>
<li>See store opening times</li>
<li>Call the store directly</li>
<li>Search for products</li>
<li>Sort by name, price and other properties</li>
<li>See product info, qualities, suitable recipes etc</li>
<li>Find the closest store with a certain product in stock</li>
<li>Save your favourite stores, products, searches and recipes</li>
</ul>


<p>Â </p>


<p>We'll spill all the beans about the development of Systemet later, but I can tell you right now that it took some serious Titanium, HTML5, and YQL wizardry to make this happen, and that our "database" is a plain ol' Google Docs Spreadsheet.</p>


<p>Curious, ha? Stay tuned!</p>


<p>Â </p>

]]></content>
  </entry>
  
</feed>
